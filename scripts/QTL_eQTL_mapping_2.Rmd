---
title: "QTL_eQTL_mapping_2"
author: "Ruijuan Li"
date: "5/13/2018"
output: 
  html_document: 
    keep_md: yes
---

# load libraries 
```{r}
library(tidyverse) 
library(qtl) 
library(Biostrings)  
```

### QTL mapping result output 
```{r}
setwd("~/Desktop/F2_paper/submission/Li-eQTL-2018/")
load("input/QTL_result_all.Rdata")

### summarize QTL mapping result  
threshold.95 <- tibble(perm.threshold = bind_rows(scanone.perm.imp.all) %>% as.numeric(), 
                       trait = colnames(bind_rows(scanone.perm.imp.all)))

scanone.qtl.2 <-  
bind_cols(scanone.imp.all) %>% 
  dplyr::select(chr, pos, starts_with("lod"))
rownames(scanone.qtl.2) <- rownames(scanone.imp.all$Crude_oil_contents)
colnames(scanone.qtl.2)[3:ncol(scanone.qtl.2)] <- names(scanone.imp.all)

scanone.gather <- scanone.qtl.2 %>%
  gather(key = trait, value = LOD, -chr, -pos) %>%
  left_join(threshold.95)

sig.chrs <- scanone.gather %>% dplyr::filter(LOD > perm.threshold) %>%
  group_by(trait,chr) %>%
  dplyr::summarise(count = n())

# now for each significant chromosome/trait combo run bayesint
bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(scanone.qtl.2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  
 
names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x)  
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr))
) 

bayesint.list %>% length() # 33
bayesint.list.scanone <- bayesint.list 

bayesint.result.scanone <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD), genetic_start=min(pos, na.rm = T), genetic_end=max(pos, na.rm = T)) %>% 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.
  mutate(start=ifelse(start==end,max(0,start-20000),start), end=ifelse(start==end,end+20000,end))

bayesint.result.scanone %>% dim() # 33 8 

### cim
threshold.95 <- tibble(perm.threshold = bind_rows(cim.perm.all) %>% as.numeric(), 
                       trait = colnames(bind_rows(cim.perm.all)))

cim.qtl.2 <-  
bind_cols(cim.qtl.all) %>% 
  dplyr::select(chr, pos, starts_with("lod"))

rownames(cim.qtl.2) <- rownames(cim.qtl.all$Crude_oil_contents)
colnames(cim.qtl.2)[3:ncol(cim.qtl.2)] <- names(cim.qtl.all)

cim.gather <- cim.qtl.2 %>%
  gather(key = trait, value = LOD, -chr, -pos) %>%
  left_join(threshold.95)

# look for overlap, for each trait, find QTL border and look for genes under QTL peaks 
sig.chrs <- cim.gather %>% dplyr::filter(LOD > perm.threshold) %>%
  group_by(trait,chr) %>%
  dplyr::summarise(count = n()) 

# now for each significant chromosome/trait combo run bayesint
bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(cim.qtl.2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  

names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x)  
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr))
) 

bayesint.list %>% length() # 26 

# save bayesint result for later 
bayesint.list.cim <- bayesint.list

bayesint.result.cim <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD), genetic_start=min(pos, na.rm = T), genetic_end=max(pos, na.rm = T)) %>% 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.
  mutate(start=ifelse(start==end,max(0,start-20000),start), end=ifelse(start==end,end+20000,end))

bayesint.result.cim %>% dim() # 26 8

bayesint.result.cim$model <- rep("cim", nrow(bayesint.result.cim))
bayesint.result.scanone$model <- rep("scanone", nrow(bayesint.result.scanone))

bayesint.result <- 
bayesint.result.cim %>% 
  full_join(bayesint.result.scanone, by = c("trait", "chr")) 

bayesint.result %>% dim() # 35 16 

for (i in 1:nrow(bayesint.result)){
  if(is.na(bayesint.result[i, "start.x"])){
    bayesint.result[i, c(3:9)] <- bayesint.result[i, c(10:16)]
  }
}

bayesint.result <- bayesint.result[,1:9] 
colnames(bayesint.result) <- gsub("\\.x$", "", colnames(bayesint.result)) 

bayesint.result %>% dim() # 35 9 

# make Table 2
length(bayesint.list.scanone) # 33
length(bayesint.list.cim) # 26 

bayesint.result.scanone <- as.tibble(bind_rows(bayesint.list.scanone,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(pos, na.rm = T),end=max(pos, na.rm = T),pos = median(pos, na.rm = T), LOD=max(LOD))  

bayesint.result.scanone %>% dim() # 33 6 

bayesint.result.tmp <- as.tibble(bind_rows(bayesint.list.scanone,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  # separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) 

bayesint.result.tmp$index <- paste(bayesint.result.tmp$trait, bayesint.result.tmp$chr, bayesint.result.tmp$LOD)
bayesint.result.scanone$index <- paste(bayesint.result.scanone$trait, bayesint.result.scanone$chr, bayesint.result.scanone$LOD)

test <- 
bayesint.result.tmp %>% 
  anti_join(bayesint.result.scanone) %>% 
  dplyr::select(trait, chr, markername) %>% 
  mutate(index = paste(trait, chr, sep = "_")) 

tmp <- c()

for (i in seq_along(1:(nrow(test)/2))){
  tmp[i] <- paste(test$markername[i*2-1], test$markername[i*2-0], sep = "-") 
}

bayesint.result.scanone$index <- tmp

bayesint.result.scanone <- 
bayesint.result.scanone %>%
  mutate(start = round(start, 2), end = round(end, 2), pos = round(pos, 2), LOD = round(LOD, 2)) %>%
  unite(confidence_interval, start, end, sep = "-") %>% 
  mutate(flanking_marker = index) %>% 
  dplyr::select(-index)  

bayesint.result.scanone %>% dim() # 33 6 

### cim result 
bayesint.list.cim %>% length() # 26

bayesint.result <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(pos, na.rm = T),end=max(pos, na.rm = T),pos = median(pos, na.rm = T), LOD=max(LOD)) 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.

bayesint.result %>% dim() # 26 6 

bayesint.result.tmp <- as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  # separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) 

bayesint.result.tmp$index <- paste(bayesint.result.tmp$trait, bayesint.result.tmp$chr, bayesint.result.tmp$LOD)
bayesint.result$index <- paste(bayesint.result$trait, bayesint.result$chr, bayesint.result$LOD)

test <- 
bayesint.result.tmp %>% 
  anti_join(bayesint.result) %>% 
  dplyr::select(trait, chr, markername) %>% 
  mutate(index = paste(trait, chr, sep = "_")) 

tmp <- c()

for (i in seq_along(1:(nrow(test)/2))){
  tmp[i] <- paste(test$markername[i*2-1], test$markername[i*2-0], sep = "-") 
}

bayesint.result$index <- tmp 

bayesint.result.cim <- 
bayesint.result %>% 
  mutate(start = round(start, 2), end = round(end, 2), pos = round(pos, 2), LOD = round(LOD, 2)) %>%
  unite(confidence_interval, start, end, sep = "-") %>% 
  mutate(flanking_marker = index) %>% 
  dplyr::select(-index)  

bayesint.result.cim %>% dim() # 26 6  

### combine cim & scanone result 
bayesint.result.scanone$model <- rep("scanone", nrow(bayesint.result.scanone))
bayesint.result.cim$model <- rep("cim", nrow(bayesint.result.cim))

bayesint.result.paper <- 
bayesint.result.cim %>% 
  full_join(bayesint.result.scanone, by = c("trait", "chr")) 

bayesint.result.paper %>% dim() # 32 12

for (i in 1:nrow(bayesint.result.paper)){
  if(is.na(bayesint.result.paper[i, "pos.x"])){
    bayesint.result.paper[i, c(3:7)] <- bayesint.result.paper[i, c(8:12)]
  }
}

bayesint.result.paper <- bayesint.result.paper[,1:7] 
colnames(bayesint.result.paper) <- gsub("\\.x$", "", colnames(bayesint.result.paper)) 

bayesint.result.paper %>% dim() # 35 7 

write.csv(bayesint.result.paper, file = "output/bayesint.result.paper.csv") 

### combine with allele effect information, allelic effect was calculated using fitqtl(), and values were added to bayesint.result.paper.csv  
bayesint.result.allele_effect <- read.csv("input/bayesint.result.paper_allele_effect.csv")

bayesint.result.paper.final <- 
bayesint.result.paper %>%
  left_join(bayesint.result.allele_effect, by = c("trait", "chr")) %>% 
  mutate(model = model.x) %>%
  dplyr::select(-model.x, -model.y, -X) 

### add physical position interval  
bayesint.result.scanone <- as.tibble(bind_rows(bayesint.list.scanone,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD))

bayesint.result.cim <- as.tibble(bind_rows(bayesint.list.cim,.id="trait")) %>% # combine list into tibble 
  dplyr::select(trait,chr,pos,markername,LOD) %>% 
  separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T),min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD))

bayesint.result.cim$model <- rep("cim", nrow(bayesint.result.cim))
bayesint.result.scanone$model <- rep("scanone", nrow(bayesint.result.scanone))

bayesint.result <- 
bayesint.result.cim %>% 
  full_join(bayesint.result.scanone, by = c("trait", "chr")) 

for (i in 1:nrow(bayesint.result)){
  if(is.na(bayesint.result[i, "start.x"])){
    bayesint.result[i, c(3:7)] <- bayesint.result[i, c(8:12)]
  }
}

bayesint.result <- bayesint.result[,1:7] 
colnames(bayesint.result) <- gsub("\\.x$", "", colnames(bayesint.result)) 

bayesint.result %>% dim() # 35 7 

bayesint.result.physical <-
bayesint.result.paper.final %>% 
  left_join(bayesint.result, by= c("trait", "chr")) %>% 
  mutate(model = model.x) %>% 
  dplyr::select(-min_eQTL_LOD, -max_eQTL_LOD, -model.y, -model.x) 
  
bayesint.result.physical 
write.csv(bayesint.result.physical, file = "output/bayesint.result.paper.physical.csv") 

# annotate QTL   
load("input/BnapusAnnotation.Rdata") 

traitQTL.annotated <- lapply(1:nrow(bayesint.result),function(row) { # for each trait/module 
  qtl <- bayesint.result[row,]  
  results <- subset(BnapusAnnotation, chrom==qtl$chr &
                    start >= qtl$start & # genes which fall into the QTL interval 
                    end <= qtl$end)
} 
)  

names(traitQTL.annotated) <- bayesint.result$trait 

traitQTL.annotated <- bind_rows(traitQTL.annotated,.id="trait") %>% # combine list into data.frame 
  mutate(chrom=as.character(chrom)) %>%
  left_join(bayesint.result,by=c("trait","chrom"="chr")) #get eQTL LOD

traitQTL.annotated <- 
traitQTL.annotated %>% 
  mutate(start = start.y, end = end.y) %>% 
  dplyr::select(-start.x, -end.x, -start.y, -end.y, -min_eQTL_LOD, -max_eQTL_LOD) 

traitQTL.annotated %>% dim() # 18647     11

## get GO term for each gene
load("input/napus_GO_combined.Rdata") 

colnames(traitQTL.annotated)[3] <- "gene_ID"

traitQTL.annotated <- 
traitQTL.annotated %>% 
  left_join(napus_GO_combined) 

traitQTL.annotated %>% dim() #  18647    13 
save(traitQTL.annotated, file =  "output/traitQTL.annotated.flipped.Rdata")  
```

### eQTL mapping result output  
```{r}
# determine cis- and trans- eQTL 
load("input/scanone-eqtl_F2_flipped_C05C08.RData")
scanone_eQTL.F2 %>% dim() # 4944 56182 

scanone_eQTL.F2$chr <- as.character(scanone_eQTL.F2$chr) 

# get threshold 
threshold.95 <- lod.thrs[5,] 
threshold.95 # 4.18 

# get all eQTL based on this threshold   
eQTL_sign <- 
sapply(colnames(scanone_eQTL.F2), function(gene) {
  sum(scanone_eQTL.F2[,gene] > threshold.95) > 0 
}) 

sum(eQTL_sign) # 22,695 genes with eQTL 
scanone_eQTL.F2 <- scanone_eQTL.F2[,eQTL_sign]  
dim(scanone_eQTL.F2) # 4944 22695  

# get bayesint result for every gene 
scanone.gather <-  
scanone_eQTL.F2 %>% 
  gather(key = trait, value = LOD, -chr, -pos) 

sig.chrs <- scanone.gather %>% filter(LOD > threshold.95) %>% 
  group_by(trait,chr) %>% 
  dplyr::summarise(count = n()) # this is to get the significant chr ID for each trait 

sig.chrs %>% dim() # 26244         3

bayesint.list <- apply(sig.chrs,1,function(hit) { # for every row("trait, chr, count") in eigengene module 
    result <- bayesint(scanone_eQTL.F2[c("chr","pos",hit["trait"])],  
                     chr=hit["chr"], 
                     lodcolumn = 1, 
                     expandtomarkers = TRUE 
  )
  colnames(result)[3] <- "LOD" 
  result
})  

names(bayesint.list) <- sig.chrs$trait

bayesint.list <- lapply(bayesint.list,function(x) 
                          x %>% 
                          as.data.frame() %>%
                          rownames_to_column(var="markername")  %>% # make rownames to column and use "markername" as the colname for the new colomn  
                          mutate(chr=as.character(chr)) 
)  

bayesint.result <- 
as.tibble(bind_rows(bayesint.list,.id="trait")) %>% # combine list into tibble 
    dplyr::select(trait,chr,pos,markername,LOD) %>%  
    separate(markername,into=c("chr1","Mbp"),sep="_", convert=TRUE) %>%  
    group_by(trait,chr) %>% 
    dplyr::summarize(start=min(Mbp, na.rm = T),end=max(Mbp, na.rm = T), pos=median(pos, na.rm = T), min_eQTL_LOD=min(LOD),max_eQTL_LOD=max(LOD), genetic_start=min(pos, na.rm = T), genetic_end=max(pos, na.rm = T)) %>% 
  #for the high QTL peaks the interval width is 0.  That is overly precise and need to widen those.
  # mutate(start=ifelse(start==end, start-20000,start), end=ifelse(start==end,end+20000,end)) 
  mutate(start_modified=ifelse(start-1000000>0, start-1000000, 0), end_modified=end+1000000) 

bayesint.result %>% dim() # 26244    11

# get genome range 
library(IRanges)
library(GenomicRanges)
library(GenomicFeatures) 
library("rtracklayer") 

### get gff file with gene chrom & pos info, gff3 file must be sorted 
gff.mRNA <- read.table("~/Reference/B.napus/gff.mRNA")
dim(gff.mRNA) # 101040      4 
colnames(gff.mRNA) <- c("gene_CHROM", "gene_start", "gene_end", "gene_ID") 

# look for cis-eQTL 
bayesint.result.2 <- 
bayesint.result %>% 
  mutate(gene_ID = trait, eQTL_chr = chr, eQTL_start = start_modified, eQTL_end = end_modified) %>% 
  dplyr::select(trait, gene_ID, eQTL_chr, pos, eQTL_start, eQTL_end, start, end, min_eQTL_LOD, max_eQTL_LOD, genetic_start, genetic_end) %>% 
  left_join(gff.mRNA, by = "gene_ID") 

bayesint.result.2$eQTL_chr <- paste("chr", bayesint.result.2$eQTL_chr, sep = "")

cis_eQTL <- 
bayesint.result.2 %>% 
  filter(eQTL_chr == gene_CHROM) %>% 
  filter((gene_start < eQTL_start & gene_end > eQTL_start) | # also need SNP pos... 
         (gene_start >= eQTL_start & gene_end <= eQTL_end) |
         (gene_start < eQTL_end & gene_end > eQTL_end)) 

dim(cis_eQTL) # 11587    15

trans_eQTL <- 
bayesint.result.2 %>% 
  anti_join(cis_eQTL) 

# output plot 
cis_eQTL$index <- paste(cis_eQTL$eQTL_chr, cis_eQTL$eQTL_start, cis_eQTL$eQTL_end, sep = "_")
trans_eQTL$index <- paste(trans_eQTL$eQTL_chr, trans_eQTL$eQTL_start, trans_eQTL$eQTL_end, sep = "_")

cis_eQTL$class <- rep("cis", nrow(cis_eQTL))  
trans_eQTL$class <- rep("trans", nrow(trans_eQTL))   

# get only main chromosome stuff   
eQTL <- rbind(cis_eQTL, trans_eQTL) 
eQTL <- eQTL[grep("random", eQTL$gene_CHROM, value = FALSE, invert = T),] # random scaffolds are exluced 
eQTL$class <- factor(eQTL$class, levels = c("cis", "trans"))
eQTL$gene_CHROM <- gsub("(chr)([[:print:]]+)", "\\2", eQTL$gene_CHROM)
eQTL$eQTL_chr <- gsub("(chr)([[:print:]]+)", "\\2", eQTL$eQTL_chr)
eQTL$gene_CHROM <- factor(eQTL$gene_CHROM, levels = c("C09", "C08", "C07", "C06", "C05", "C04", "C03", "C02", "C01", "A10", "A09", "A08", "A07", "A06", "A05", "A04", "A03", "A02", "A01"))
eQTL$eQTL_chr <- factor(eQTL$eQTL_chr, levels = c("A01", "A02", "A03", "A04", "A05", "A06", "A07", "A08", "A09", "A10", "C01", "C02", "C03", "C04", "C05", "C06", "C07", "C08", "C09"))

# plot   
p.eQTL <- 
eQTL %>% 
  ggplot() + 
  geom_point(aes(x = pos, y = gene_start, color = class), size = 0.5) +
  facet_grid(gene_CHROM ~ eQTL_chr, switch = "both", scales = "free") + 
  theme_classic() + 
  theme(panel.spacing = unit(0, "lines"), panel.border = element_rect(colour = "black", fill=NA, size=0.1)) + 
  theme(axis.text.x=element_blank(),
        axis.text.y=element_blank(), 
        axis.ticks.x=element_blank(),
        axis.ticks.y=element_blank()) + 
  labs(x = "eQTL genetic position", y = "gene start") + 
  theme(text = element_text(size=8)) + 
  scale_color_manual(values=c("red", "royalblue"))  

p.eQTL    

# trans-eQTL hotspot 

```

### integrate QTL and eQTL mapping result 
```{r}
# cis-coding candidates 


# cis-regulator candidates


# trans-regulator target candidates


# plot important candidates 
```

